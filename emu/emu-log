#!/bin/bash

source /usr/local/lib/libemu
EMU_ECHO_PREFIX=$(basename "$0")

# print the nodes for a sink
#  @param $1 name of sink
print_all_node_details ()
{
    local sink="$1"
    local counter=0

    for node in $(ls "$SINK_DIR/$EMU_DIR/nodes" | sort -r)
    do
        counter=$((counter+1))
        if [[ $counter -le $EMU_LOG_MAX ]]
        then
            if (( $(cat .emu_log | wc -l ) )) && ! (( $EMU_LOG_SUMMARY ))
            then
                echo ""
            fi
            print_node_details "$node"
        fi
    done
}

main ()
{
    EMU_LOG_MAX=10000

    test -n "$EMU_DEBUG" && set -x
    exit_on_help_version $@

    while getopts ":n:s" OPT
    do
        case $OPT in
            n)
                EMU_LOG_MAX=$OPTARG
                ;;
            s)
                EMU_LOG_SUMMARY=1
                ;;
            \?)
                emu_error "invalid option: -$OPTARG"
                exit 1
                ;;
            :)
                emu_error "option -$OPTARG requires an argument"
                exit 1
                ;;
        esac
    done

    # dispose of args
    while [ "${1:0:1}" = "-" ]
    do
        shift
    done

    get_source_dir_or_fail
    execute_hooks "pre" "$SOURCE_DIR"

    local arg_list="$@"

    if [ -z "$1" ]
    then
        # if no argument is given, generate a sink list of all sinks
        arg_list="$(ls "$SOURCE_DIR/$EMU_DIR/sinks")"
    fi

    if ! (( $(ls "$SOURCE_DIR/$EMU_DIR/sinks" | wc -l) ))
    then
        # there are no sinks
        emu_error "no sinks. See 'emu help sink'"
        emu_panic
        exit $EMU_EXIT_ERROR
    fi

    rm -f .emu_log
    touch .emu_log

    for arg in $arg_list
    do
        local in=$(echo "$1" | tr ":" "\n")
        local sink=""
        local snapshot=""

        if [[ $(echo "$in" | wc -l) -eq 2 ]]
        then
            # <sink>:<snapshot> format
            sink=$(echo "$in" | head -n1)
        else
            # not a ':' delimited input
            sink="$arg"
        fi

        if [[ ! -f "$SOURCE_DIR/$EMU_DIR/sinks/$sink" ]]
        then
            emu_error "sink '$sink' does not exist"
            rm -f .emu_log
            emu_panic
            exit $EMU_EXIT_ERROR
        fi

        SINK_DIR="$(cat $SOURCE_DIR/$EMU_DIR/sinks/$sink 2>/dev/null)"

        if [ -z "$SINK_DIR" ] || [[ ! -d "$SINK_DIR" ]]
        then
            # sink files do not exist
            emu_error "sink '$sink' is corrrupt"
            rm -f .emu_log
            emu_panic
            exit $EMU_EXIT_ERROR
        fi

        if [[ $(echo "$in" | wc -l) -eq 2 ]]
        then
            # <sink>:<snapshot> format
            snapshot=$(echo "$in" | tail -n1)

            if [ "$snapshot" = "HEAD" ]
            then
                snapshot="$(cat "$SINK_DIR/$EMU_DIR/HEAD")"
            fi

            if [[ ! -d "$SINK_DIR/$EMU_DIR/trees/$snapshot" ]]
            then
                emu_error "snapshot '$snapshot' does not exist"
                rm -f .emu_log
                emu_panic
                exit $EMU_EXIT_ERROR
            fi
        fi

        if [ -z "$snapshot" ]
        then
            if [[ $(cat .emu_log | wc -l) -gt 0 ]]
            then
                echo "" >> .emu_log
            fi
            print_sink_details "$sink" >> .emu_log
            print_all_node_details "$sink" >> .emu_log
        else
            print_node_details "$snapshot" > .emu_log
        fi
    done

    less .emu_log
    rm -f .emu_log

    execute_hooks "post" "$SOURCE_DIR"
    exit 0
}
main $@
