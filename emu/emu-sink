#!/bin/sh

source /usr/local/lib/libemu
EMU_ECHO_PREFIX=$(basename "$0")
SOURCE_DIR="$(pwd)"

help ()
{
    man $(basename "$0")
}

init_sink ()
{
    SINK_DIR="$1"
    TEMPLATE_DIR="/usr/local/share/emu/sink-templates"

    exit_if_no_dir_permissions "$1"
    mkdir $EMU_VERBOSE -p "$SINK_DIR/.emu"
    mkdir $EMU_VERBOSE -p "$SINK_DIR/.emu/trees"
    mkdir $EMU_VERBOSE -p "$SINK_DIR/.emu/nodes"
    mkdir $EMU_VERBOSE -p "$SINK_DIR/.emu/config"
    touch "$SINK_DIR/.emu/HEAD"
    echo $(pwd) > "$SINK_DIR/.emu/SOURCE"
    cp -n $EMU_VERBOSE "$TEMPLATE_DIR/config/SNAPSHOT-COUNT" "$SINK_DIR/.emu/config"

    if ! (( $EMU_QUIET ))
    then
        emu_echo "initialized sink at $SINK_DIR/.emu"
    fi
}

add_sink ()
{
    if [[ "$1" == "" ]] || [[ "$2" == "" ]]
    then
        help
        exit 1
    fi

    # Get absolute path.
    if [ ${2:0:1} != "/" ]
    then
        SINK_PATH="$(pwd)/$2"
    else
        SINK_PATH="$2"
    fi

    if [[ -f ".emu/sinks/$1" ]]
    then
        emu_error "sink '$1' already exists"
        exit 1
    fi

    if [[ -d "$SINK_PATH/.emu/trees" ]]
    then
        emu_error "'$SINK_PATH' is already an emu sink"
        exit 1
    fi

    exit_if_no_dir_permissions ".emu"

    echo "$SINK_PATH" > ".emu/sinks/$1"

    # Initialize sink.
    init_sink "$SINK_PATH"
}

rm_sink ()
{
    if [[ ! -f ".emu/sinks/$1" ]]
    then
        emu_error "sink '$1' does not exist"
        exit 1
    fi

    if (( $EMU_RM_SINK ))
    then
        rm $EMU_VERBOSE -rf "$(cat .emu/sinks/$1)"
    fi

    rm $EMU_VERBOSE -f ".emu/sinks/$1"
    if ! (( $EMU_QUIET ))
    then
        emu_echo "sink '$1' removed"
    fi
}

show_sink ()
{
    if [[ $@ == "" ]]
    then
        SINKS="$(ls .emu/sinks)"
    else
        FAILURE=0
        for ARG in $@
        do
            if [[ -f ".emu/sinks/$ARG" ]]
            then
                SINKS="$SINKS\n$ARG"
            else
                emu_error "sink '$ARG' does not exist"
                FAILURE=1
            fi

            if [[ FAILURE -ne 0 ]]
            then
                exit_with_error
            fi

            SINKS="$(echo -e SINKS | tail -n+2)"
        done
    fi

    for SINK in $SINKS
    do
        print_sink_details "$SINK"
    done
}

list_sinks ()
{
    if [ -z $EMU_VERBOSE ]
    then
        ls ".emu/sinks"
    else
        for SINK in $(ls ".emu/sinks")
        do
            echo "$SINK  ->  $(cat .emu/sinks/$SINK)"
        done
    fi
}

main ()
{
    while getopts ":qvs:Rt:" OPT
    do
        case $OPT in
            q)
                EMU_QUIET=1
                ;;
            v)
                EMU_VERBOSE="-v"
                ;;
            s)
                EMU_SNAPSHOT_COUNT="$OPTARG"
                ;;
            R)
                EMU_RM_SINK=1
                ;;
            t)
                EMU_SOURCE_TEMPLATE_DIR="$OPTARG"
                if [ ! -d "$EMU_SOURCE_TEMPLATE_DIR" ]
                then
                    emu_error "'$OPTARG' not a directory"
                    exit 1
                fi
                ;;
            \?)
                emu_error "invalid option: -$OPTARG"
                exit 1
                ;;
            :)
                emu_error "option -$OPTARG requires an argument"
                exit 1
                ;;
        esac
    done

    # Dispose of args.
    while [ "${1:0:1}" = "-" ]
    do
        shift
    done

    if [ "$1" = "help" ]
    then
        help
        exit 0
    fi

    if [ ! -d "$SOURCE_DIR/.emu/sinks" ]
    then
        emu_error "not an emu source"
        exit_with_error
    fi

    case "$1" in
        "")
            list_sinks
            ;;
        "add")
            shift
            add_sink $1 $2
            ;;
        "rm")
            shift
            rm_sink $@
            ;;
        "show")
            shift
            show_sink $@
            ;;
        *)
            exit_command_not_found "$1"
            ;;
    esac

    exit 0
}
main $@
