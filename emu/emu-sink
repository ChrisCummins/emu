#!/bin/sh

source /usr/local/lib/libemu
SCRIPT=$(basename $0)
SOURCE_DIR="$(pwd)"

help ()
{
    man emu-sink
}

init_sink ()
{
    SINK_DIR="$1"
    TEMPLATE_DIR="/usr/local/share/emu/sink-templates"

    exit_if_no_dir_permissions "$1"
    mkdir $EMU_VERBOSE -p "$SINK_DIR/.$PROG"
    mkdir $EMU_VERBOSE -p "$SINK_DIR/.$PROG/trees"
    mkdir $EMU_VERBOSE -p "$SINK_DIR/.$PROG/nodes"
    mkdir $EMU_VERBOSE -p "$SINK_DIR/.$PROG/config"
    touch "$SINK_DIR/.$PROG/HEAD"
    echo $(pwd) > "$SINK_DIR/.$PROG/SOURCE"
    cp -n $EMU_VERBOSE "$TEMPLATE_DIR/config/SNAPSHOT-COUNT" "$SINK_DIR/.$PROG/config"

    if ! (( $EMU_QUIET ))
    then
        echo "$SCRIPT: Initialized sink at $SINK_DIR/.$PROG"
    fi
}

add_sink ()
{
    if [[ "$1" == "" ]] || [[ "$2" == "" ]]
    then
        help
        exit 1
    fi

    # Get absolute path.
    if [ ${2:0:1} != "/" ]
    then
        SINK_PATH="$(pwd)/$2"
    else
        SINK_PATH="$2"
    fi

    if [[ -f ".$PROG/sinks/$1" ]]
    then
        echo "$SCRIPT: Sink '$1' already exists." >&2
        exit 1
    fi

    if [[ -d "$SINK_PATH/.$PROG/trees" ]]
    then
        echo "$SCRIPT: '$SINK_PATH' is already an emu sink." >&2
        exit 1
    fi

    exit_if_no_dir_permissions ".$PROG"

    echo "$SINK_PATH" > ".$PROG/sinks/$1"

    # Initialize sink.
    init_sink "$SINK_PATH"
}

rm_sink ()
{
    if [[ ! -f ".$PROG/sinks/$1" ]]
    then
        echo "$SCRIPT: Sink '$1' does not exist." >&2
        exit 1
    fi

    if (( $EMU_RM_SINK ))
    then
        rm $EMU_VERBOSE -rf "$(cat .$PROG/sinks/$1)"
    fi

    rm $EMU_VERBOSE -f ".$PROG/sinks/$1"
    if ! (( $EMU_QUIET ))
    then
        echo "$SCRIPT: Sink '$1' removed."
    fi
}

show_sink ()
{
    if [[ $@ == "" ]]
    then
        SINKS=$(ls ".$PROG/sinks")
    else
        FAILURE=0
        for ARG in $@
        do
            if [[ -f ".$PROG/sinks/$ARG" ]]
            then
                SINKS="$SINKS\n$ARG"
            else
                echo "$SCRIPT: Sink '$ARG' does not exist!" >&2
                FAILURE=1
            fi

            if [[ FAILURE -ne 0 ]]
            then
                exit_with_error
            fi

            SINKS="$(echo -e SINKS | tail -n+2)"
        done
    fi

    for SINK in $SINKS
    do
        print_sink_details "$SINK"
    done
}

list_sinks ()
{
    if [ -z $EMU_VERBOSE ]
    then
        ls ".$PROG/sinks"
    else
        for SINK in $(ls ".$PROG/sinks")
        do
            echo "$SINK  ->  $(cat .$PROG/sinks/$SINK)"
        done
    fi
}

main ()
{
    while getopts ":qvs:Rt:" OPT
    do
        case $OPT in
            q)
                EMU_QUIET=1
                ;;
            v)
                EMU_VERBOSE="-v"
                ;;
            s)
                EMU_SNAPSHOT_COUNT="$OPTARG"
                ;;
            R)
                EMU_RM_SINK=1
                ;;
            t)
                EMU_SOURCE_TEMPLATE_DIR="$OPTARG"
                if [ ! -d "$EMU_SOURCE_TEMPLATE_DIR" ]
                then
                    echo "$SCRIPT: '$OPTARG' not a directory" >&2
                    exit 1
                fi
                ;;
            \?)
                echo "$SCRIPT: invalid option: -$OPTARG" >&2
                exit 1
                ;;
            :)
                echo "$SCRIPT: option -$OPTARG requires an argument." >&2
                exit 1
                ;;
        esac
    done

    # Dispose of args.
    while [ "${1:0:1}" = "-" ]
    do
        shift
    done

    if [ "$1" = "help" ]
    then
        help
        exit 0
    fi

    if [ ! -d "$SOURCE_DIR/.$PROG/sinks" ]
    then
        echo "$SCRIPT: not an $PROG source!" >&2
        exit_with_error
    fi

    case "$1" in
        "")
            list_sinks
            ;;
        "add")
            shift
            add_sink $1 $2
            ;;
        "rm")
            shift
            rm_sink $@
            ;;
        "show")
            shift
            show_sink $@
            ;;
        *)
            no_command_error "$SCRIPT" "$1"
            ;;
    esac

    exit 0
}
main $@
