#!/bin/sh

source /usr/local/lib/libemu
EMU_ECHO_PREFIX=$(basename "$0")

help ()
{
    man $(basename "$0")
}

init_sink ()
{
    SINK_DIR="$1"
    TEMPLATE_DIR="/usr/local/share/emu/sink-templates"

    exit_if_no_dir_permissions "$1"
    mkdir $EMU_VERBOSE -p "$SINK_DIR/.emu"
    mkdir $EMU_VERBOSE -p "$SINK_DIR/.emu/trees"
    mkdir $EMU_VERBOSE -p "$SINK_DIR/.emu/nodes"
    mkdir $EMU_VERBOSE -p "$SINK_DIR/.emu/config"
    touch "$SINK_DIR/.emu/HEAD"
    echo $(pwd) > "$SINK_DIR/.emu/SOURCE"
    cp -n $EMU_VERBOSE "$TEMPLATE_DIR/config/SNAPSHOT-COUNT" "$SINK_DIR/.emu/config"

    if ! (( $EMU_QUIET ))
    then
        emu_echo "initialized sink at $SINK_DIR/.emu"
    fi
}

add_sink ()
{
    local sink_name="$1"
    local sink_path="$2"

    if [ -z "$sink_name" ] || [ -z "$sink_path" ]
    then
        help
        exit $EMU_EXIT_INCORRECT_COMMAND
    fi

    if [[ -f ".emu/sinks/$sink_name" ]]
    then
        emu_error "sink '$sink_name' already exists"
        exit 1
    fi

    exit_if_no_dir_permissions ".emu"

    # get absolute path
    mkdir -p "$sink_path"
    sink_path="$(get_absolute_path "$sink_path")"
    pushd . &>/dev/null
    cd "$sink_path"
    if is_sink
    then
        emu_error "'$sink_path' is already an emu sink"
        exit $EMU_EXIT_ERROR
    fi
    popd &>/dev/null

    echo "$sink_path" > ".emu/sinks/$sink_name"

    # initialize sink
    init_sink "$sink_path"
}

rm_sink ()
{
    if [[ ! -f ".emu/sinks/$1" ]]
    then
        emu_error "sink '$1' does not exist"
        exit 1
    fi

    if (( $EMU_RM_SINK ))
    then
        rm $EMU_VERBOSE -rf "$(cat .emu/sinks/$1)"
    fi

    rm $EMU_VERBOSE -f ".emu/sinks/$1"
    if ! (( $EMU_QUIET ))
    then
        emu_echo "sink '$1' removed"
    fi
}

show_sink ()
{
    if [[ $@ == "" ]]
    then
        SINKS="$(ls .emu/sinks)"
    else
        FAILURE=0
        for ARG in $@
        do
            if [[ -f ".emu/sinks/$ARG" ]]
            then
                SINKS="$SINKS\n$ARG"
            else
                emu_error "sink '$ARG' does not exist"
                FAILURE=1
            fi

            if [[ FAILURE -ne 0 ]]
            then
                exit_with_error
            fi

            SINKS="$(echo -e SINKS | tail -n+2)"
        done
    fi

    for SINK in $SINKS
    do
        print_sink_details "$SINK"
    done
}

list_sinks ()
{
    if [ -z $EMU_VERBOSE ]
    then
        ls ".emu/sinks"
    else
        for SINK in $(ls ".emu/sinks")
        do
            echo "$SINK  ->  $(cat .emu/sinks/$SINK)"
        done
    fi
}

main ()
{
    while getopts ":qvs:Rt:" OPT
    do
        case $OPT in
            q)
                EMU_QUIET=1
                ;;
            v)
                EMU_VERBOSE="-v"
                ;;
            s)
                EMU_SNAPSHOT_COUNT="$OPTARG"
                ;;
            R)
                EMU_RM_SINK=1
                ;;
            t)
                EMU_SOURCE_TEMPLATE_DIR="$OPTARG"
                if [ ! -d "$EMU_SOURCE_TEMPLATE_DIR" ]
                then
                    emu_error "'$OPTARG' not a directory"
                    exit 1
                fi
                ;;
            \?)
                emu_error "invalid option: -$OPTARG"
                exit 1
                ;;
            :)
                emu_error "option -$OPTARG requires an argument"
                exit 1
                ;;
        esac
    done

    # Dispose of args.
    while [ "${1:0:1}" = "-" ]
    do
        shift
    done

    if [ "$1" = "help" ]
    then
        help
        exit 0
    fi

    get_source_dir_or_fail

    if [ ! -d "$SOURCE_DIR/.emu/sinks" ]
    then
        emu_error "not an emu source"
        exit_with_error
    fi

    case "$1" in
        "")
            list_sinks
            ;;
        "add")
            shift
            add_sink $1 $2
            ;;
        "rm")
            shift
            rm_sink $@
            ;;
        "show")
            shift
            show_sink $@
            ;;
        *)
            command_not_found "$1"
            ;;
    esac

    exit 0
}
main $@
