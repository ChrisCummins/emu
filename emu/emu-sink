#!/bin/sh

source /usr/share/emu/emu-util
SCRIPT=$(basename $0)
SOURCE_DIR="$(pwd)"

help ()
{
    cat <<EOF | less
NAME
        $SCRIPT - manage $PROG sinks

SYNOPSIS
        $PROG snapshot [OPTION...] [add|rm|rename|show] <args>...

DESCRIPTION

        With no arguments, show a list of existing sinks. Several subommands are
        available to perform operations on sinks.

OPTIONS
        add <sink> <path>

                   initializes an empty sink named <sink> in the directory
                   <path>. This means creating a .$PROG directory at <path> with
                   subdirectories for trees, refs/nodes and configuration
                   files. If necessary, <path> will be created. Each sink <sink>
                   must be unique, and each <path> must not already be an $PROG
                   sink/source, unless it is a detached sink. A detached sink
                   means that it refs the current source, but the current source
                   does not acknowledge it as a sink. This happens if you
                   attempt to add a sink that has previously be removed with
                   '$PROG rm'. In this situation, '$PROG add' will behave the
                   same way that '$PROG init' does in an existing
                   source. Additionally the command takes the following options:

                -s <number>
                    set the maximum number of snapshots for the new sink. This
                    is a convenience option which saves the user editing the
                    .$PROG/config/SNAPSHOT-COUNT file themselves. If this
                    argument is ommitted, the default value will be dictated by
                    the contents of the
                    /usr/share/emu/sink-templates/config/SNAPSHOT-COUNT template
                    file

        rm <sink>
                   remove sink <sink> from the source refs. This does not affect
                   the sink file structure and is non-destructive, except with
                   the use of arguments:

                -R
                    force removal of the sink directory itself. This means that
                    all snapshots, configurations and all other files in the
                    sink directory will be permanently wiped. Use with extreme
                    caution, double up to be safe

        mv <old> <new>
                   rename sink <old> to <new>. This does not affect any of the
                   location of the sink or its files

        show <sink>
                   gives some information about the sink <sink>

EOF
}

init_sink ()
{
    SINK_DIR="$1"
    TEMPLATE_DIR="/usr/share/emu/sink-templates"

    mkdir -p "$SINK_DIR/.$PROG"
    mkdir -p "$SINK_DIR/.$PROG/trees"
    mkdir -p "$SINK_DIR/.$PROG/nodes"
    mkdir -p "$SINK_DIR/.$PROG/config"
    touch "$SINK_DIR/.$PROG/HEAD"
    echo $(pwd) > "$SINK_DIR/.$PROG/SOURCE"
    cp -n "$TEMPLATE_DIR/config/SNAPSHOT-COUNT" "$SINK_DIR/.$PROG/config"

    echo "$SCRIPT: Initialized sink at $SINK_DIR/.$PROG"
}

add_sink ()
{
    if [[ "$1" == "" ]] || [[ "$2" == "" ]]
    then
        help
        exit 1
    fi

    if [[ -f ".$PROG/sinks/$1" ]]
    then
        echo "$SCRIPT: Sink '$1' already exists." >&2
        exit 1
    fi

    if [[ -d "$2/.$PROG" ]]
    then
        echo "$SCRIPT: '$2/.$PROG' already exists." >&2
        exit 1
    fi

    # Create sinks/remote file.
    echo "$2" > ".$PROG/sinks/$1"

    # Initialize sink.
    init_sink "$2"
}

rm_sink ()
{
    if [[ ! -f ".$PROG/sinks/$1" ]]
    then
        echo "$SCRIPT: Sink '$1' does not exist." >&2
        exit 1
    fi

    rm -f ".$PROG/sinks/$1"
    echo "$SCRIPT: Sink '$1' removed."
}

show_sink ()
{
    if [[ $@ == "" ]]
    then
        SINKS=$(ls ".$PROG/sinks")
    else
        FAILURE=0
        for ARG in $@
        do
            if [[ -f ".$PROG/sinks/$ARG" ]]
            then
                SINKS="$SINKS\n$ARG"
            else
                echo "$SCRIPT: Sink '$ARG' does not exist!" >&2
                FAILURE=1
            fi

            if [[ FAILURE -ne 0 ]]
            then
                exit_with_error
            fi

            SINKS="$(echo -e SINKS | tail -n+2)"
        done
    fi

    for SINK in $SINKS
    do
        print_sink_details "$SINK"
    done
}

list_sinks ()
{
    ls ".$PROG/sinks"
}

main ()
{
    COMMAND="$1"
    shift

    if [[ "$COMMAND" == "help" ]]
    then
        help
        exit 0
    fi

    if [ ! -d "$SOURCE_DIR/.$PROG/sinks" ]
    then
        echo "$SCRIPT: not an $PROG source!" >&2
        exit_with_error
    fi

    case "$COMMAND" in
        "")
            list_sinks
            ;;
        "add")
            add_sink $1 $2
            ;;
        "rm")
            rm_sink $@
            ;;
        "show")
            show_sink $@
            ;;
        *)
            no_command_error "$SCRIPT" "$COMMAND"
            ;;
    esac

    exit 0
}
main $@
