#!/bin/sh

source /usr/share/emu/emu-util
SCRIPT=$(basename $0)
SOURCE_DIR="$(pwd)"

# Retrieve all sink files.
#
# @return SINK_FILES List of paths to sink files.
get_all_sinks ()
{
    SINK_FILES="$(find $SOURCE_DIR/.$PROG/sinks/ | tail -n+2)"

    if [[ "$SINK_FILES" == "" ]]
    then
        echo "$SCRIPT: no sinks! Add one with '$PROG sink add <name> <path>'" >&2
        exit_with_error
    fi

    # Check for all sync files.
    for SINK_FILE in $SINK_FILES
    do
        SINK="$(cat $SINK_FILE)"
        if [[ ! -d "$SINK/.$PROG" ]]
        then
            echo -e "$SCRIPT: sink does not exist:\n  $SINK\n" >&2
            exit_with_error
        fi
    done
}

# Convert a list of sinks to sink files.
#
# @param $@ List of sinks.
# @return SINK_FILES List of sink files paths.
get_sinks ()
{
    SINK_FILES[$#]=$@
    for ARG in $@
    do
        SINK_FILE="$(find $SOURCE_DIR/.$PROG/sinks/ -name $ARG)"
        if [[ "$SINK_FILE" == "" ]]
        then
            echo "$SCRIPT: sink '$ARG' not found!" >&2
            exit_with_error
        fi
        SINK_FILES="$SINK_FILES\n$SINK_FILE"
    done
    SINK_FILES="$(echo -e $SINK_FILES | tail -n+2)"
}

# Generate a snapshot hash.
#
# @param $1 Path to sink directory.
# @return HASH a 40 digit snapshot UID.
generate_hash ()
{
    HASH=$(find . -type f -printf '%T@ %p\n' 2>/dev/null|sort -k 1nr \
        |sed 's/^[^ ]* //'|head -n10|md5sum)
    HASH=${HASH:0:32}
    HASH=$HASH$(printf '%x\n' $(date +'%s')|tail -c8)

    # Check if hash exists, and if so, wait.
    if [[ -f "$1/.$PROG/nodes/$HASH" ]]
    then
        sleep 2
        generate_hash
    fi
}

# Generate a snapshot node file.
#
# @param $1 Path to sink directory.
# @var $HEAD The UID of the parent snapshot.
# @var $HASH The 40 digit snapshot UID.
generate_node ()
{
    NODE="$1/.$PROG/nodes/$HASH"
    touch "$NODE"
    cat <<EOF >> "$NODE"
Parent  $HEAD
Date    $(date)
Source  $(cat $1/.$PROG/SOURCE)
Size    $(du -sh "$1/.$PROG/trees/In Progress..." | sed -r 's/([0-9a-zA-Z]+)\s.*/\1/')
EOF
chmod 0640 "$NODE"
}

# Fetch the head of the sink tree, if there is one.
#
# @param $1 Path to sink directory.
# @return HEAD The UID of the HEAD snapshot.
# @return RSYNC_LINK The rsync link command, pointed to head.
get_rsync_link ()
{
    HEAD="$(cat $1/.$PROG/HEAD)"
    if [[ "$HEAD" != "" ]] && [[ -d "$1/.$PROG/trees/$HEAD" ]]
    then
        RSYNC_LINK="--link-dest=$1/.$PROG/trees/$HEAD"
    else
        RSYNC_LINK=""
    fi
}

# Push the latest snapshot to HEAD.
#
# @param $1 Path to sink directory.
# @var HASH The UID of the latest snapshot.
push_head ()
{
    mv "$1/.$PROG/trees/In Progress..." "$1/.$PROG/trees/$HASH"
    rm -f "$1/.$PROG/HEAD"
    echo "$HASH" > "$1/.$PROG/HEAD"
}

# Fetch the parent of the current snapshot.
#
# @param $1 Path to sink directory.
# @param $2 Starting hash.
# @return Next hash, or empty string if NULL.
get_snapshot_parent ()
{
    echo "$(cat $1/.$PROG/nodes/$2 2>/dev/null | grep Parent | sed -r 's/Parent +//')"
}

# Fetch the child of the current snapshot.
#
# @param $1 Path to sink directory.
# @param $2 Hash of starting point.
# @param $3 Target hash.
# @return SNAPSHOT_HASH The has of the last snapshot.
get_snapshot_child ()
{
    NEXT_SNAPSHOT_HASH="$2"
    while [[ "$NEXT_SNAPSHOT_HASH" != "$3" ]]
    do
        SNAPSHOT_HASH="$NEXT_SNAPSHOT_HASH"
        NEXT_SNAPSHOT_HASH="$(get_snapshot_parent $1 $SNAPSHOT_HASH)"
    done
}

# Deletes a snapshot.
#
# @param $1 Path to sink directory.
# @param $2 UID of snapshot to delete.
remove_snapshot ()
{
    get_snapshot_child "$1" "$(cat $1/.$PROG/HEAD)" $2
    cat "$1/.$PROG/nodes/$SNAPSHOT_HASH" | sed -r 's/(Parent +).*$/\1/' > "$1/.$PROG/nodes/$SNAPSHOT_HASH"
    echo "$SINK_NAME: removing $2"
    rm -f "$1/.$PROG/nodes/$2"
    rm -rf "$1/.$PROG/trees/$2"
}

# Remove the oldest in tree in a set of snapshots.
#
# @param $1 Path to sink directory.
pop_tail ()
{
    get_snapshot_child "$1" "$(cat $1/.$PROG/HEAD)"
    remove_snapshot "$1" "$SNAPSHOT_HASH"
}

# Push the latest snapshot to HEAD.
#
# @param $1 Path to sink directory.
pop_tails ()
{
    while [[ $(sink_snapshot_count "$1") -ge $(sink_max_snapshots "$1") ]]
    do
        NEXT_SNAPSHOT_HASH="$(cat $1/.$PROG/HEAD)"
        pop_tail "$1"
    done
}

# Perform the a snapshot on sink.
#
# @param $1 Path to sink directory.
# @param $2 Name of sink.
# @return Integer success value (non-zero indicates failure)
perform_snapshot_on_sink ()
{
    lock_dir "$1"
    get_rsync_link "$1"
    pop_tails "$1"
    echo -n "$2: creating snapshot ($(sink_snapshot_count $1) of "
    echo "$(sink_max_snapshots $1))"

    rsync \
        --delete \
        --delete-excluded \
        --archive \
        --human-readable \
        --verbose \
        --exclude-from="$SOURCE_DIR/.$PROG/excludes" \
        "$RSYNC_LINK" \
        "$SOURCE_DIR/" "$1/.$PROG/trees/In Progress..."
    if (( $? ))
    then
        unlock_dir "$1"
        return 3
    fi

    generate_hash "$1"
    generate_node "$1"
    push_head "$1"

    unlock_dir "$1"
    echo "$2: new HEAD $HASH"
    return 0
}

# Perform snapshots on all sink files.
#
# @var $SINK_FILES List of paths to sink files.
perform_snapshots ()
{
    SNAPSHOT_FAILED=0

    for SINK_FILE in $SINK_FILES
    do
        SINK="$(cat $SINK_FILE)"
        SINK_NAME="$(basename $SINK_FILE)"

        perform_snapshot_on_sink "$SINK" "$SINK_NAME"
        if (( $? ))
        then
            SNAPSHOT_FAILED=1
            echo "$SCRIPT: snapshot to '$SINK_NAME' failed" >&2
        fi
    done

    return $SNAPSHOT_FAILED
}

main ()
{
    pre_exec_hooks "$SOURCE_DIR"
    if [[ "$@" == "" ]]
    then
        get_all_sinks
    else
        get_sinks $@
    fi
    lock_dir "$SOURCE_DIR"
    perform_snapshots
    if (( $? ))
    then
        echo "$SCRIPT: at least one snapshot failed!" >&2
        exit_with_error
    fi
    unlock_dir "$SOURCE_DIR"
    post_exec_hooks "$SOURCE_DIR"
}
main
