#!/bin/sh

source /usr/share/emu/emu-util
SCRIPT=$(basename $0)
SOURCE_DIR="$(pwd)"

help ()
{
    cat << EOF | less
NAME
        $SCRIPT - record a snapshot of the source directory

SYNOPSIS
        $PROG snapshot [OPTION...] [<sink>...]

DESCRIPTION
        Store the current contents of the source directory in a new snapshot.

        The difference between the content of the source and the last snapshot
        in the sink is added to the sink and linked against the existing
        content, combining to produce a full snapshot of the source
        directory. This enables $PROG sinks to be very compact, allowing
        multiple full snapshots to be stored in a space little larger than a
        single full snapshot.

        $PROG refers to the directory to be backed up as the "source" and the
        backup destination as the "sink". This is analogous to a electrical
        sources and sinks, the critical difference being of course that data can
        flow from the sink back to the source (in the case of a restore).

        Some of the features of the snapshot features are:

        o      supports copying links, devices, owners, groups, and permissions

        o      exclude and exclude-from options in .$PROG/excludes

        o      does not require super-user privileges

        $PROG uses the rsync file-copying tool for its delta-transfer algorithm,
        which reduces the amount of data sent by sending only the differences
        between the source files and the existing files in the sink.

        Rsync finds files that need to be transferred using a "quick check"
        algorithm (by default) that looks for files that have changed in size or
        in last-modified time.

OPTIONS
        -m <message>
                   add a snapshot message <message>
        -M [<editor>]
                   open an editor to add a snapshot message (use EDITOR
                   variable, if <editor> argument not given
        -n
                   perform a trial run with no changes made, equivalent to
                   '$PROG status'
        -v
                   increase verbosity
        -p
                   show progress during transfer
        -f
                   force snapshot. This causes the program to disregard any
                   exclusivity locks that the source or sink directories may
                   have. Not recommended for everyday consumption, but is useful
                   after a previous snapshot attempt failed
        -F
                   equivalent to -f force option, but in addition causing $PROG
                   to kill any process owning a sink or source lock and removing
                   any in-progress snapshot data. Exercise caution or heads will
                   explode

EOF
}

# Retrieve all sink files.
#
# @return SINK_FILES List of paths to sink files.
get_all_sinks ()
{
    SINK_FILES="$(find $SOURCE_DIR/.$PROG/sinks/ | tail -n+2)"

    if [[ "$SINK_FILES" == "" ]]
    then
        echo "$SCRIPT: no sinks! Add one with '$PROG sink add <name> <path>'" >&2
        exit_with_error
    fi

    # Check for all sync files.
    for SINK_FILE in $SINK_FILES
    do
        SINK="$(cat $SINK_FILE)"
        if [[ ! -d "$SINK/.$PROG" ]]
        then
            echo -e "$SCRIPT: sink does not exist:\n  $SINK\n" >&2
            exit_with_error
        fi
    done
}

# Convert a list of sinks to sink files.
#
# @param $@ List of sinks.
# @return SINK_FILES List of sink files paths.
get_sinks ()
{
    SINK_FILES[$#]=$@
    for ARG in $@
    do
        SINK_FILE="$(find $SOURCE_DIR/.$PROG/sinks/ -name $ARG)"
        if [[ "$SINK_FILE" == "" ]]
        then
            echo "$SCRIPT: sink '$ARG' not found!" >&2
            exit_with_error
        fi
        SINK_FILES="$SINK_FILES\n$SINK_FILE"
    done
    SINK_FILES="$(echo -e $SINK_FILES | tail -n+2)"
}

# Generate a snapshot hash.
#
# @param $1 Path to sink directory.
# @return HASH a 40 digit snapshot UID.
generate_hash ()
{
    HASH=$(hash_directory "$1/.$PROG/trees/new")
    HASH=$HASH$(printf '%x\n' $(date +'%s') | tail -c8)

    # Check if hash exists, and if so, wait.
    if [[ -f "$1/.$PROG/nodes/$HASH" ]]
    then
        sleep 1
        generate_hash "$1"
    fi
}

# Gnerate a snapshot name.
#
# @param $1 Path to sink directory.
# @var HASH the 40 digit snapshot UID.
# @return SNAPSHOT a snapshot name
generate_snapshot_name ()
{
    SNAPSHOT=$(date -d @$(printf '%d' 0x5${HASH:32:8}) +'%Y-%m-%d %T')
}

# Generate a snapshot node file.
#
# @param $1 Path to sink directory.
# @var $HEAD The UID of the parent snapshot.
# @var $HASH The 40 digit snapshot UID.
generate_node ()
{
    NODE="$1/.$PROG/nodes/$HASH"
    touch "$NODE"
    cat <<EOF >> "$NODE"
Snapshot $SNAPSHOT
Parent   $HEAD
Date     $(date)
Source   $(cat $1/.$PROG/SOURCE)
Size     $(du -sh "$1/.$PROG/trees/$HASH" | sed -r 's/([0-9a-zA-Z]+)\s.*/\1/')
EOF
    chmod 0640 "$NODE"
}

# Fetch the head of the sink tree, if there is one.
#
# @param $1 Path to sink directory.
# @return HEAD The UID of the HEAD snapshot.
# @return RSYNC_LINK The rsync link command, pointed to head.
get_rsync_link ()
{
    HEAD="$(cat $1/.$PROG/HEAD)"
    if [[ "$HEAD" != "" ]] && [[ -d "$1/.$PROG/trees/$HEAD" ]]
    then
        RSYNC_LINK="--link-dest=$1/.$PROG/trees/$HEAD"
    else
        RSYNC_LINK=""
    fi
}

# Push the latest snapshot to HEAD.
#
# @param $1 Path to sink directory.
# @var HASH The UID of the latest snapshot.
push_head ()
{
    rm -f "$1/.$PROG/HEAD"
    echo "$HASH" > "$1/.$PROG/HEAD"
}

# Fetch the parent of the current snapshot.
#
# @param $1 Path to sink directory.
# @param $2 Starting hash.
# @return Next hash, or empty string if NULL.
get_snapshot_parent ()
{
    echo "$(cat $1/.$PROG/nodes/$2 2>/dev/null | grep Parent | sed -r 's/Parent +//')"
}

# Fetch the child of the current snapshot.
#
# @param $1 Path to sink directory.
# @param $2 Hash of starting point.
# @param $3 Target hash.
# @return SNAPSHOT_HASH The hash of the snapshot's child.
get_snapshot_child ()
{
    NEXT_SNAPSHOT_HASH="$2"
    while [[ "$NEXT_SNAPSHOT_HASH" != "$3" ]]
    do
        SNAPSHOT_HASH="$NEXT_SNAPSHOT_HASH"
        NEXT_SNAPSHOT_HASH="$(get_snapshot_parent $1 $SNAPSHOT_HASH)"
    done
}

# Deletes a snapshot.
#
# @param $1 path to sink directory.
# @param $2 snapshot to delete.
remove_snapshot ()
{
    get_snapshot_child "$1" "$(cat $1/.$PROG/HEAD)" "$2"
    cat "$1/.$PROG/nodes/$SNAPSHOT_HASH" | sed -r 's/(Parent +).*$/\1/' > "$1/.$PROG/nodes/$SNAPSHOT_HASH"
    echo "$SINK_NAME: removing $2"
    rm -f "$1/.$PROG/nodes/$2"
    rm -f "$1/.$PROG/nodes/$2.msg"
    rm -rf "$1/.$PROG/trees/$2"
    rm -rf "$1/$(date -d @$(printf '%d' 0x5${2:32:8}) +'%Y-%m-%d %T')"
}

# Remove the oldest in tree in a set of snapshots.
#
# @param $1 Path to sink directory.
pop_tail ()
{
    # Get the root snapshot (one with no child).
    get_snapshot_child "$1" "$(cat $1/.$PROG/HEAD)"
    remove_snapshot "$1" "$SNAPSHOT_HASH"
}

# Push the latest snapshot to HEAD.
#
# @param $1 Path to sink directory.
pop_tails ()
{
    while [[ $(sink_snapshot_count "$1") -ge $(sink_max_snapshots "$1") ]]
    do
        NEXT_SNAPSHOT_HASH="$(cat $1/.$PROG/HEAD)"
        pop_tail "$1"
    done
}

# Perform the a snapshot on sink.
#
# @param $1 Path to sink directory.
# @param $2 Name of sink.
# @return Integer success value (non-zero indicates failure)
perform_snapshot_on_sink ()
{
    lock_dir "$1"
    get_rsync_link "$1"
    pop_tails "$1"
    echo -n "$SCRIPT: $2: creating snapshot ($(sink_snapshot_count $1) of "
    echo "$(sink_max_snapshots $1))"

    rsync \
        --delete \
        --delete-excluded \
        --archive \
        --human-readable \
        --exclude-from="$SOURCE_DIR/.$PROG/excludes" \
        "$RSYNC_LINK" \
        "$SOURCE_DIR/" "$1/.$PROG/trees/new"
    if (( $? ))
    then
        unlock_dir "$1"
        return 3
    fi

    generate_hash "$1"
    generate_snapshot_name "$1"
    mv "$1/.$PROG/trees/new" "$1/.$PROG/trees/$HASH"
    ln -s "$1/.$PROG/trees/$HASH" "$1/$SNAPSHOT"
    generate_node "$1"
    push_head "$1"

    unlock_dir "$1"
    echo "$SCRIPT: $2: new snapshot '$SNAPSHOT'"
    echo "$SCRIPT: $2: HEAD at $HASH"
    return 0
}

# Perform snapshots on all sink files.
#
# @var $SINK_FILES List of paths to sink files.
perform_snapshots ()
{
    SNAPSHOT_FAILED=0

    for SINK_FILE in $SINK_FILES
    do
        SINK="$(cat $SINK_FILE)"
        SINK_NAME="$(basename $SINK_FILE)"

        perform_snapshot_on_sink "$SINK" "$SINK_NAME"
        if (( $? ))
        then
            SNAPSHOT_FAILED=1
            echo "$SCRIPT: snapshot to '$SINK_NAME' failed" >&2
        fi
    done

    return $SNAPSHOT_FAILED
}

main ()
{
    if [ "$1" = "help" ]
    then
        help
        exit 0
    fi

    pre_exec_hooks "$SOURCE_DIR"
    if [[ "$@" == "" ]]
    then
        get_all_sinks
    else
        get_sinks $@
    fi
    lock_dir "$SOURCE_DIR"
    perform_snapshots
    if (( $? ))
    then
        echo "$SCRIPT: at least one snapshot failed!" >&2
        exit_with_error
    fi
    unlock_dir "$SOURCE_DIR"
    post_exec_hooks "$SOURCE_DIR"
}
main $@
