#!/bin/sh

source /usr/local/lib/libemu
EMU_ECHO_PREFIX=$(basename "$0")

help ()
{
    man emu-snapshot
}

# Retrieve all sink files.
#
# @return SINK_FILES List of paths to sink files.
get_all_sinks ()
{
    SINK_FILES="$(find $SOURCE_DIR/.emu/sinks/ | tail -n+2)"

    if [[ "$SINK_FILES" == "" ]]
    then
        emu_error "no sinks! Add one with 'emu sink add <name> <path>'"
        emu_panic
        exit $EMU_EXIT_INCORRECT_COMMAND
    fi

    # Check for all sync files.
    for SINK_FILE in $SINK_FILES
    do
        SINK="$(cat $SINK_FILE)"
        if [[ ! -d "$SINK/.emu" ]]
        then
            emu_error "sink does not exist:\n  $SINK\n"
            emu_panic
            exit $EMU_EXIT_ERROR
        fi
    done
}

# Convert a list of sinks to sink files.
#
# @param $@ List of sinks.
# @return SINK_FILES List of sink files paths.
get_sinks ()
{
    SINK_FILES[$#]=$@
    for ARG in $@
    do
        SINK_FILE="$(find $SOURCE_DIR/.emu/sinks/ -name $ARG)"
        if [[ "$SINK_FILE" == "" ]]
        then
            emu_error "sink '$ARG' not found!"
            emu_panic
            exit $EMU_EXIT_INCORRECT_COMMAND
        fi
        SINK_FILES="$SINK_FILES\n$SINK_FILE"
    done
    SINK_FILES="$(echo -e $SINK_FILES | tail -n+2)"
}

# Generate a snapshot hash.
#
# @param $1 Path to sink directory.
# @return HASH a 40 digit snapshot UID.
generate_hash ()
{
    HASH=$(hash_directory "$1/.emu/trees/new")
    HASH=$HASH$(printf '%x\n' $(date +'%s') | tail -c8)

    # Check if hash exists, and if so, wait.
    if [[ -f "$1/.emu/nodes/$HASH" ]]
    then
        sleep 1
        generate_hash "$1"
    fi
}

# Gnerate a snapshot name.
#
# @param $1 Path to sink directory.
# @var HASH the 40 digit snapshot UID.
# @return SNAPSHOT a snapshot name
generate_snapshot_name ()
{
    SNAPSHOT=$(date -d @$(printf '%d' 0x5${HASH:32:8}) +'%Y-%m-%d %T')
}

# Generate a snapshot node file.
#
# @param $1 Path to sink directory.
# @var $HEAD The UID of the parent snapshot.
# @var $HASH The 40 digit snapshot UID.
generate_node ()
{
    NODE="$1/.emu/nodes/$HASH"
    touch "$NODE"
    cat <<EOF >> "$NODE"
Snapshot $SNAPSHOT
Parent   $HEAD
Date     $(date)
Source   $(cat $1/.emu/SOURCE)
Size     $(du -sh "$1/.emu/trees/$HASH" | sed -r 's/([0-9a-zA-Z]+)\s.*/\1/')
EOF
    chmod 0640 "$NODE"
}

# Fetch the head of the sink tree, if there is one.
#
# @param $1 Path to sink directory.
# @return HEAD The UID of the HEAD snapshot.
# @return RSYNC_LINK The rsync link command, pointed to head.
get_rsync_link ()
{
    HEAD="$(cat $1/.emu/HEAD)"
    if [[ "$HEAD" != "" ]] && [[ -d "$1/.emu/trees/$HEAD" ]]
    then
        RSYNC_LINK="--link-dest=$1/.emu/trees/$HEAD"
    else
        RSYNC_LINK=""
    fi
}

# Push the latest snapshot to HEAD.
#
# @param $1 Path to sink directory.
# @var HASH The UID of the latest snapshot.
push_head ()
{
    rm -f "$1/.emu/HEAD"
    echo "$HASH" > "$1/.emu/HEAD"
}

# Fetch the parent of the current snapshot.
#
# @param $1 Path to sink directory.
# @param $2 Starting hash.
# @return Next hash, or empty string if NULL.
get_snapshot_parent ()
{
    echo "$(cat $1/.emu/nodes/$2 2>/dev/null | grep Parent | sed -r 's/Parent +//')"
}

# Fetch the child of the current snapshot.
#
# @param $1 Path to sink directory.
# @param $2 Hash of starting point.
# @param $3 Target hash.
# @return SNAPSHOT_HASH The hash of the snapshot's child.
get_snapshot_child ()
{
    NEXT_SNAPSHOT_HASH="$2"
    while [[ "$NEXT_SNAPSHOT_HASH" != "$3" ]]
    do
        SNAPSHOT_HASH="$NEXT_SNAPSHOT_HASH"
        NEXT_SNAPSHOT_HASH="$(get_snapshot_parent $1 $SNAPSHOT_HASH)"
    done
}

# Deletes a snapshot.
#
# @param $1 path to sink directory.
# @param $2 snapshot to delete.
remove_snapshot ()
{
    get_snapshot_child "$1" "$(cat $1/.emu/HEAD)" "$2"
    cat "$1/.emu/nodes/$SNAPSHOT_HASH" | sed -r 's/(Parent +).*$/\1/' > "$1/.emu/nodes/$SNAPSHOT_HASH"
    echo "$SINK_NAME: removing $2"
    rm -f "$1/.emu/nodes/$2"
    rm -f "$1/.emu/nodes/$2.msg"
    rm -rf "$1/.emu/trees/$2"
    rm -rf "$1/$(date -d @$(printf '%d' 0x5${2:32:8}) +'%Y-%m-%d %T')"
}

# Remove the oldest in tree in a set of snapshots.
#
# @param $1 Path to sink directory.
pop_tail ()
{
    # Get the root snapshot (one with no child).
    get_snapshot_child "$1" "$(cat $1/.emu/HEAD)"
    remove_snapshot "$1" "$SNAPSHOT_HASH"
}

# Push the latest snapshot to HEAD.
#
# @param $1 Path to sink directory.
pop_tails ()
{
    while [[ $(sink_snapshot_count "$1") -ge $(sink_max_snapshots "$1") ]]
    do
        NEXT_SNAPSHOT_HASH="$(cat $1/.emu/HEAD)"
        pop_tail "$1"
    done
}

# Perform the a snapshot on sink.
#
# @param $1 Path to sink directory.
# @param $2 Name of sink.
# @return Integer success value (non-zero indicates failure)
perform_snapshot_on_sink ()
{
    lock_dir "$1"
    get_rsync_link "$1"
    pop_tails "$1"
    emu_echo "$2: creating snapshot ($(sink_snapshot_count $1) of $(sink_max_snapshots $1))"

    rsync \
        --delete \
        --delete-excluded \
        --archive \
        --human-readable \
        --exclude-from="$SOURCE_DIR/.emu/excludes" \
        "$RSYNC_LINK" \
        "$SOURCE_DIR/" "$1/.emu/trees/new"
    if (( $? ))
    then
        unlock_dir "$1"
        return 3
    fi

    generate_hash "$1"
    generate_snapshot_name "$1"
    mv "$1/.emu/trees/new" "$1/.emu/trees/$HASH"
    ln -s "$1/.emu/trees/$HASH" "$1/$SNAPSHOT"
    generate_node "$1"
    push_head "$1"

    unlock_dir "$1"
    emu_echo "$2: new snapshot '$SNAPSHOT'"
    emu_echo "$2: HEAD at $HASH"
    return 0
}

# Perform snapshots on all sink files.
#
# @var $SINK_FILES List of paths to sink files.
perform_snapshots ()
{
    SNAPSHOT_FAILED=0

    for SINK_FILE in $SINK_FILES
    do
        SINK="$(cat $SINK_FILE)"
        SINK_NAME="$(basename $SINK_FILE)"

        perform_snapshot_on_sink "$SINK" "$SINK_NAME"
        if (( $? ))
        then
            SNAPSHOT_FAILED=1
            emu_error "snapshot to '$SINK_NAME' failed"
        fi
    done

    return $SNAPSHOT_FAILED
}

main ()
{
    if [ "$1" = "help" ]
    then
        help
        exit $EMU_EXIT
    fi

    get_source_dir_or_fail
    pre_exec_hooks

    if [[ "$@" == "" ]]
    then
        get_all_sinks
    else
        get_sinks $@
    fi

    lock_dir "$SOURCE_DIR"

    perform_snapshots
    if (( $? ))
    then
        emu_error "at least one snapshot failed"
        emu_panic
        exit $EMU_EXIT_ERROR
    fi

    unlock_dir "$SOURCE_DIR"
    post_exec_hooks
}
main $@
