#!/bin/bash

source /usr/local/lib/libemu
EMU_ECHO_PREFIX=$(basename "$0")
SOURCE_DIR="$(pwd)"

help ()
{
    cat <<EOF
NAME
        $SCRIPT - verify the contents of a sink snapshot

SYNOPSIS
        emu snapshot [OPTION...] [<sink>:]<snapshot>

DESCRIPTION
        Performs a checksum of a snapshot within a sink directory, and reports
        on whether this calculated checksum matches the calculation made at the
        time of snapshot creation. If these checksums do not match, it is safe
        to assume that the snapshot is in someway corrupted or has been tampered
        with. For further details of the checksumming process, see the section
        HASH ALGORITHM.

        The format for specifying snapshot is in the form <sink>:<snapshot>. If
        this command is executed from a sink directory, the <sink>: specifier
        may be ommitted, and will be assumed to be the current sink
        directory. The <snapshot> value is the 40 digit snapshot UID, and can be
        obtained from 'emu log'.

OPTIONS
        -q
                   only print error and warning messages, all other output will
                   be suppressed

HASH ALGORITHM
        The algorithm used to determine the checksum of a snapshot is not a
        perfect hasing algorithm, that is, it would be possible to make two
        different snapshots compute to the same checksum value, giving the
        appearance that their contents are the same. This is not a mistake on
        our part, but an intentional engineering decision to try to address the
        imbalance between quality of hashing algorithms and computational
        expense.

        A traditional approach to verifying the contents of a directory would be
        be to create a list of checksums for every file in the directory and to
        then perform a checksum of this list. While this reduces the threshold
        for collisions down to that of the checksumming algorithm itself, it
        required reading every byte within the directory, and for especially
        large sources, this can be unrealistically time consuming.

        The algorithm that emu uses forgoes checksumming every file within a
        directory, trading in the ability for perfect hasing for a 2600%
        execution time decrease.

EOF
}

main ()
{
    if [ "$1" = "help" ]
    then
        help
        exit 0
    fi

    pre_exec_hooks "$SOURCE_DIR"

    IN=$(echo "$1" | tr ":" "\n")

    if [[ $(echo "$IN" | wc -l) -ne 2 ]]
    then
        if [[ $(ls "$SOURCE_DIR/.emu/sinks" | wc -l) -eq 1 ]]
        then
            SINK="$(ls $SOURCE_DIR/.emu/sinks)"
        else
            emu_error "invalid snapshot"
            emu_panic
            exit $EMU_EXIT_INCORRECT_COMMAND
        fi
    fi

    if [ "$SINK" = "" ]
    then
        SINK=$(echo "$IN" | head -n1)
    fi

    SINK_DIR="$(cat $SOURCE_DIR/.emu/sinks/$SINK 2>/dev/null)"
    if [[ ! -d "$SINK_DIR" ]]
    then
        emu_error "sink '$SINK' does not exist"
        emu_panic
        exit $EMU_EXIT_INCORRECT_COMMAND
    fi

    SNAPSHOT=$(echo "$IN" | tail -n1)
    SNAPSHOT_DIR="$SINK_DIR/.emu/trees/$SNAPSHOT"
    if [[ ! -d "$SNAPSHOT_DIR" ]]
    then
        emu_error "snapshot '$SNAPSHOT' does not exist"
        emu_panic
        exit $EMU_EXIT_INCORRECT_COMMAND
    fi

    $(verify_node "$SNAPSHOT_DIR")
    emu_echo "pass"

    post_exec_hooks "$SOURCE_DIR"
    exit 0
}
main $@
