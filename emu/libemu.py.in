#!/usr/bin/env python
#
# Copyright 2014 Chris Cummins.
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
import calendar
import time
import os
import re
import shlex
import shutil
import subprocess
import sys
from ConfigParser import ConfigParser
from optparse import OptionParser
from sys import exit
from datetime import datetime

class SnapshotNotFoundError(Exception):
    def __init__(self, hash, stack=''):
        self.hash = hash
        self.stack = stack
    def __str__(self):
        if len(self.stack):
            name = self.stack + ":" + self.hash
        else:
            name = self.hash
        return "Snapshot '{0}' not found!".format(name)

class Node:
    def __init__(self, path):
        with open(path, 'r') as f:
            node = f.read()
            self.data = {}
            for l in node.rstrip().split('\n'):
                p = re.split(r"\W+", l, 1)
                self.data[p[0]] = p[1]


class Snapshot:
    def __init__(self, shash, stack_name, stack_dir):
        self.id = shash
        self.stack = stack_name
        self.stack_dir = stack_dir
        self.checksum = self.id[8:]
        self.node = stack_dir + "/.emu/nodes/" + shash
        self.tree = stack_dir + "/.emu/trees/" + shash

        if not (Util.exists(self.node) and os.path.isdir(self.tree)):
            raise SnapshotNotFoundError(shash, stack=stack_name)

        self.snapshot = self.get_node().data['Snapshot']


    _valid = None
    def verify(self):
        if self._valid == None:
            checksum = Libemu.hash_dir(self.tree)
            self._valid = checksum == self.checksum
        return self._valid

    def __repr__(self):
        return self.stack + ":" + self.id

    def get_node(self):
        try:
            return self._node
        except AttributeError:
            self._node = Node(self.node)
            return self.get_node()

    def log(self, short=False):
        def full_log(id, node):
            s =  "snapshot " + id + "\n"
            s += "Date:    " + node.data['Date'] + "\n"
            s += "Size:    " + node.data['Size'] + "\n"
            return s
        def short_log(id, node):
            s = id + "  " + node.data['Date']
            return s

        node = Node(self.node)
        if short:
            return short_log(self.id, node)
        else:
            return full_log(self.id, node)

    def destroy(self, verbose=False):
        Util.printf("destroying snapshot {0}".format(Util.colourise(self.snapshot,
                                                                    Colours.SNAPSHOT_DELETE)),
                    prefix=self.stack, colour=Colours.OK)
        Util.rm(self.tree, must_exist=True, error=True, verbose=verbose)
        Util.rm(self.node, must_exist=True, error=True, verbose=verbose)
        Util.rm(self.stack_dir + "/" + self.snapshot,
                must_exist=True, error=True, verbose=verbose)
        # TODO: Check HEAD and reallocate if necessary

    @staticmethod
    def create(stack, dry_run=False, verbose=False):
        head = stack.get_head()
        head_id = ""

        if head:
            link_dest = head.tree
            head_id = head.id
        else:
            link_dest = None

        exclude = [stack.source + "/.emu"]
        exclude_from = [stack.source + "/.emu/excludes"]

        Util.rsync(stack.source + "/", stack.path + "/.emu/trees/new",
                   dry_run=dry_run, link_dest=link_dest,
                   exclude=exclude, exclude_from=exclude_from,
                   delete=True, delete_excluded=True,
                   error=True, verbose=verbose)

        checksum = Libemu.hash_dir(stack.path + "/.emu/trees/new")
        date = time.gmtime()
        sid = "{0:x}".format(calendar.timegm(date)) + checksum
        name = "{0}-{1:02d}-{2:02d} {3:02d}.{4:02d}.{5:02d}".format(date.tm_year,
                                                                    date.tm_mon,
                                                                    date.tm_mday,
                                                                    date.tm_hour,
                                                                    date.tm_min,
                                                                    date.tm_sec)

        # Move tree into position
        Util.mv(stack.path + "/.emu/trees/new", stack.path + "/" + name,
                verbose=verbose, must_exist=True, error=True)

        # Make trees symlink
        Util.ln_s(stack.path + "/" + name, stack.path + "/.emu/trees/" + sid,
                  verbose=verbose, error=True)

        # Get size
        size = Libemu.run("du", "-h", "-s").split()[0]

        # Create node
        with open(stack.path + "/.emu/nodes/" + sid, 'w') as f:
            f.write("Snapshot " + name + "\n" +
                    "Parent   " + head_id + "\n" +
                    "Date     " + time.strftime("%A %B %d %H:%M:%S %Y", date) + "\n" +
                    "Source   " + stack.source + "\n" +
                    "Size     " + size + "\n")

        # Update HEAD
        with open(stack.path + "/.emu/HEAD", 'w') as f:
            f.write(sid + "\n")

        return Snapshot(sid, stack.stack, stack.path)


class StackNotFoundError(Exception):
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return "Stack '{0}' not found!".format(self.name)


class StackLockError(Exception):
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return "Failed to lock stack '{0}'!".format(self.name)


class Stack:
    re = r"^([^:]+)?(:(([a-f0-9]+)|(HEAD(~([0-9]+)?)?)))?$"

    def _stack(self):
        try:
            return re.sub(self.re, r"\1", self.sid)
        except:
            return ""

    def _snapshot(self):
        try:
            s = re.sub(self.re, r"\3", self.sid)

            # HEAD~ syntax
            if re.match(r"^HEAD.*", s):
                index = 0
                if re.match(r"HEAD~.*", s):
                    index += 1
                    if re.match(r".*\d+", s):
                        index += int(re.sub(r"HEAD~", r"", s)) - 1
                ids = Util.ls(self.path + "/.emu/nodes", must_exist=True)
                try:
                    return ids[index]
                except IndexError:
                    SnapshotNotFoundError(self.stack, s)

            return s
        except:
            return ""

    def _path(self):
        try:
            pointer = self.source + "/.emu/stacks/" + self.stack
            with open(pointer, 'r') as f:
                path = f.read().strip()
                if not Util.exists(path):
                    raise
                return path
        except:
            raise StackNotFoundError(self.sid)

    def get_snapshots(self):
        if len(self.snapshot):
            ids = [self.snapshot]
        else:
            ids = Util.ls(self.path + "/.emu/nodes", must_exist=True)
        snapshots = []
        for id in ids:
            snapshots.append(Snapshot(id, self.stack, self.path))
        return snapshots


    def get_head(self):
        snapshots = self.get_snapshots()
        if len(snapshots):
            return snapshots[len(snapshots) - 1]


    def get_config(self):
        try:
            return self._config
        except AttributeError:
            self._config = ConfigParser()
            self._config.read(self.path + "/.emu/config")
            return self.get_config()

    def get_config_prop(self, section, prop, err=True):
        try:
            return self.get_config().get(section, prop)
        except:
            if err:
                Util.printf("Error parsing config file!", Colours.ERROR)
                Util.printf("Could not find property '{0}' in section '{1}'".format(prop, section),
                            Colours.ERROR)
                sys.exit(1)
            return ""

    def get_max_snapshots(self):
        try:
            return self._max_snapshots
        except AttributeError:
            self._max_snapshots = int(self.get_config_prop('Snapshots', 'Max Number'))
            return self.get_max_snapshots()

    def get_disk_usage(self):
        try:
            return self._du
        except AttributeError:
            self._du = Libemu.du(self.path)
            return self.get_disk_usage()


    def lock(self, verbose=False):
        return 501


    def unlock(self, verbose=False):
        return 501


    def push(self, dry_run=False, verbose=False):
        self.lock()

        # Remove old snapshots first
        while len(self.get_snapshots()) >= int(self.get_max_snapshots()):
            self.get_snapshots()[0].destroy(verbose)

        Util.printf("pushing snapshot ({0} of {1})".format(len(self.get_snapshots()) + 1,
                                                           self.get_max_snapshots()),
                    prefix=self.stack, colour=Colours.OK)
        snapshot = Snapshot.create(self, verbose=verbose)

        self.unlock()
        Util.printf("HEAD at {0}".format(snapshot.id),
                    prefix=self.stack, colour=Colours.OK)
        Util.printf("new snapshot {0}".format(Util.colourise(snapshot.snapshot,
                                                             Colours.SNAPSHOT_NEW)),
                    prefix=self.stack, colour=Colours.OK)
        return 0


    def __init__(self, snapshot_id, source_dir, allow_snapshot_id=True):

        # Throw an exception if we have get stack:snapshot syntax and
        # we don't want it:
        if re.search(r":", snapshot_id) and not allow_snapshot_id:
            raise StackNotFoundError(snapshot_id)

        self.sid = snapshot_id
        self.source = source_dir
        self.stack = self._stack()
        self.path = self._path()
        self.snapshot = self._snapshot()

    def __str__(self):
        return self.stack + " " + self.path


class SourceCreateError(Exception):
    def __init__(self, source_dir):
        self.source_dir = source_dir
    def __str__(self):
        return "Failed to create source at '{0}'!".format(self.source_dir)


class SourceLockError(Exception):
    def __init__(self, source_dir):
        self.source_dir = source_dir
    def __str__(self):
        return "Failed to lock source '{0}'!".format(self.source_dir)


class Source:
    def __init__(self, source_dir):
        self.path = source_dir
        Util.exists(self.path, error=True)
        Util.exists(self.path + "/.emu", error=True)
        Util.exists(self.path + "/.emu/stacks", error=True)


    def checkout(self, snapshot):
        # TODO: checkout snapshot
        return 501


    def lock(self, verbose=False):
        return 501


    def unlock(self, verbose=False):
        return 501


    # stacks() - Get a source's stacks
    #
    # Returns a list of Stack objects.
    def stacks(self):
        try:
            return self._stacks
        except AttributeError:
            try:

                # Generate list of stacks:
                self._stacks = []
                for name in Util.ls(self.path + "/.emu/stacks", must_exist=True):
                    self._stacks.append(Stack(name, self.path))
                return self._stacks

            except StackNotFoundError as e:
                print e
                sys.exit(1)


    @staticmethod
    def create(path, template_dir, verbose=False, force=False):
        def err_cb(*data):
            Util.rm(source_root, verbose=verbose)
            raise SourceCreateError(source_root)

        # Create directory structure
        source_root = path + "/.emu"
        directories = ["/", "/hooks", "/stacks"]
        for d in directories:
            Util.mkdir(source_root + d, mode=0700, verbose=verbose, error=True)

        # Copy template files
        Util.rsync(template_dir + "/", source_root + "/", error=err_cb,
                   archive=True, verbose=verbose, update=force)

        return Source(path)


class Libemu:
    prefix = "/usr/local"
    global_template_dir = prefix + "/share/emu/templates"
    version = {
        "major": 0,
        "minor": 0,
        "micro": 8
    }
    version_string = (str(version["major"]) + "." +
                      str(version["minor"]) + "." +
                      str(version["micro"]))


    @staticmethod
    def show_version_and_quit(*data):
        print "emu version", Libemu.version_string
        exit(0)

    @staticmethod
    def show_help_and_quit(*data):
        # Call man page for command
        Util.p_exec("man " + os.path.basename(sys.argv[0]), error=True)
        exit(0)


    @staticmethod
    def get_option_parser():
        parser = OptionParser(add_help_option=False)

        parser.add_option("-S", "--source-dir", action="store", type="string",
                          dest="source_dir", default=os.getcwd())
        parser.add_option("--version", action="callback",
                          callback=Libemu.show_version_and_quit)
        parser.add_option("-v", "--verbose", action="store_true",
                          dest="verbose", default=False)
        parser.add_option("-h", "--help", action="callback",
                          callback=Libemu.show_help_and_quit)
        return parser


    @staticmethod
    def run(*args):
        proc = subprocess.Popen(args, stdout=subprocess.PIPE)
        out = []
        for line in proc.stdout:
            out.append(line)

        return "\n".join(out)


    @staticmethod
    def get_snapshots(args, source_dir):
        def resolve(arg, source_dir):
            try:
                return Stack(arg, source_dir).get_snapshots()
            except (StackNotFoundError, SnapshotNotFoundError) as e:
                print e
                sys.exit(1)

        if not len(args):
            args = Util.ls(source_dir + "/.emu/stacks", must_exist=True)

        snapshots = []
        for arg in args:
            snapshots += resolve(arg, source_dir)

        return snapshots


    @staticmethod
    def get_stacks(args, source):
        def resolve(arg, source):
            try:
                return Stack(arg, source.path, allow_snapshot_id=False)
            except StackNotFoundError as e:
                print e
                sys.exit(1)

        if not len(args):
            args = Util.ls(source.path + "/.emu/stacks", must_exist=True)

        stacks = []
        for arg in args:
            stacks.append(resolve(arg, source))

        return stacks


    @staticmethod
    def die_if_not_source(path):
        if not (os.path.isdir(path + "/.emu") and
                Util.exists(path + "/.emu/config")):
            print "No emu source found!"
            sys.exit(1)


    @staticmethod
    def hash_dir(path):
        command = ("cd {0} && find . -type f -printf '%T@ %p\n' 2>/dev/null | "
                   "grep -v ' ./.emu/' | md5sum | awk '{{print $1}}'").format(path)

        return subprocess.check_output(command, shell=True).rstrip()

##############################################
# Utility static class with helper functions #
##############################################
class Util:


    # exists() - Check that a path exists
    #
    # If 'error' is True and 'path' does not exist, then exit fatally
    # with error code. If 'error' is a callback function, then execute
    # it on no path existing.
    @staticmethod
    def exists(path, error=False):
        exists = os.path.exists(path)
        if error and not exists:
            if hasattr(err, '__call__'):
                # Execute error callback if provided
                error()
            else:
                # Else fatal error
                print "'" + path + "' not found!"
                sys.exit(1)
        return exists


    # readable() - Check that the user has read permissions for path
    #
    # If 'error' is True and 'path' is not readable, then exit fatally
    # with error code. If 'error' is a callback function, then execute
    # it on no read permissions.
    @staticmethod
    def readable(path, error=False):
        read_permission = os.access(path, os.R_OK)
        if error and not read_permission:
            if hasattr(error, '__call__'):
                # Execute error callback if provided
                error()
            else:
                # Else fatal error
                print "No read permissions for directory '" + path + "'!"
                sys.exit(1)
        return read_permission


    # writable() - Check that the user has write permissions for path
    #
    # If 'error' is True and 'path' is not writable, then exit fatally
    # with error code. If 'error' is a callback function, then execute
    # it on no write permissions.
    @staticmethod
    def writable(path, error=False):
        write_permission = os.access(path, os.W_OK)
        if error and not write_permission:
            if hasattr(error, '__call__'):
                # Execute error callback if provided
                error()
            else:
                # Else fatal error
                print "No read permissions for directory '" + path + "'!"
                sys.exit(1)
        return write_permission


    # rm() - Recursively remove files
    #
    # Argument 'error' can either by a boolean that dictates whether
    # to exit fatally on error, or a callback function to execute. If
    # 'must_exist' is True, then error if the file doesn't exist. This
    # function returns boolean on whether a file was deleted or not.
    @staticmethod
    def rm(path, must_exist=False, error=False, verbose=False):
        exists = Util.exists(path, error=must_exist)

        if exists:
            Util.writable(path, error=error)

            try:
                if os.path.islink(path):
                    os.unlink(path)
                    type = "link"
                elif os.path.isdir(path):
                    shutil.rmtree(path)
                    type = "directory"
                else:
                    os.remove(path)
                    type = "file"

                if verbose:
                    print "Deleted {0} '{1}'".format(type, path)
                return True

            # Failed to remove path:
            except:
                if hasattr(error, '__call__'):
                    # Execute error callback if provided
                    error()
                elif error:
                    # Fatal error if required
                    print "Failed to delete '" + path + "'."
                    sys.exit(1)
                else:
                    return False

        # Path does not exist:
        else:
            return False


    # ls() - List a directory's contents
    #
    # Returns an alphabetically sorted list of a directory's contents.
    # Argument 'error' can either by a boolean that dictates whether
    # to exit fatally on error, or a callback function to execute. If
    # 'must_exist' is True, then error if the file doesn't exist.
    @staticmethod
    def ls(path, must_exist=False, error=False):
        exists = Util.exists(path, error=must_exist)
        readable = Util.readable(path, error=error)

        if exists and readable:
            return sorted(os.listdir(path))
        else:
            return []


    # mv() - Move a file
    #
    # Returns true if file is moved, else False. Argument 'error' can
    # either by a boolean that dictates whether to exit fatally on
    # error, or a callback function to execute. If 'must_exist' is
    # True, then error if the file doesn't exist.
    @staticmethod
    def mv(src, dst, must_exist=False, error=False, verbose=False):
        exists = Util.exists(src, error=must_exist)
        readable = Util.readable(src, error=error)

        if exists and readable:
            try:
                shutil.move(src, dst)

                if verbose:
                    print "Moved '{0}' -> '{1}'".format(src, dst)

                return True
            except:
                # Error in file move:
                if hasattr(error, '__call__'):
                    # Execute error callback if provided
                    error()
                elif error:
                    # Fatal error if required
                    print "Failed to move '{0}' to '{1}'.".format(src, dst)
                    sys.exit(1)
                else:
                    return False

        # Source does not exist or unreadable:
        else:
            return False


    # ln_s() - Create a symbolic link
    #
    # Returns True is symbolic link is created, else False. Argument
    # 'error' can either by a boolean that dictates whether to exit
    # fatally on error, or a callback function to execute.
    @staticmethod
    def ln_s(src, dst, error=False, verbose=False):
        exists = Util.exists(src, error=error)

        if exists:
            try:
                os.symlink(src, dst)

                if verbose:
                    print "Link '{0}' -> '{1}'".format(src, dst)

                return True
            except:
                # Error in operation:
                if hasattr(error, '__call__'):
                    # Execute error callback if provided
                    error()
                elif error:
                    # Fatal error if required
                    print "Failed to move '{0}' to '{1}'.".format(src, dst)
                    sys.exit(1)
                else:
                    return False

        # Source does not exist:
        else:
            return False


    # mkdir() - Create a directory and all required parents
    #
    # Returns True if directory is created, else False. Argument
    # 'error' can either by a boolean that dictates whether to exit
    # fatally on error, or a callback function to execute.
    @staticmethod
    def mkdir(path, mode=0777, fail_if_already_exists=False,
              error=False, verbose=False):
        exists = Util.exists(path, fail_if_already_exists)

        if exists:
            return False
        else:
            try:
                os.makedirs(path, mode)

                if verbose:
                    print "Created directory '{0}' with mode 0{1:o}".format(path, mode)

                return True
            except:
                # Error in operation:
                if hasattr(error, '__call__'):
                    # Execute error callback if provided
                    error()
                elif error:
                    # Fatal error if required
                    print "Failed to create directory '{0}'.".format(path)
                    sys.exit(1)
                else:
                    return False


    # p_exec() - Execute a child subprocess
    #
    # Returns a subprocess instance generated by Popen. If 'wait' is
    # True, process will block until subprocess hash
    # completed. Argument 'error' can either by a boolean that
    # dictates whether to exit fatally on error, or a callback
    # function to execute. The 'stdin', 'stdout', and 'stderr'
    # arguments are handlers for their respective IO streams.
    @staticmethod
    def p_exec(args, stdin=None, stdout=None, stderr=None,
               wait=True, error=False, verbose=False):

        if isinstance(args, basestring):
            args = shlex.split(args)

        if verbose:
            print "Executing '{0}'.".format(" ".join(args))

        process = subprocess.Popen(args, stdin=stdin, stdout=stdout,
                                   stderr=stderr)

        if wait:
            process.wait()

        if error and process.returncode:
            # Error in operation:
            if hasattr(error, '__call__'):
                # Execute error callback if provided
                error()
            elif error:
                # Fatal error if required
                print "Failed to execute '{0}'.".format(" ".join(args))
                sys.exit(1)

        return process


    # rsync() - Execute rsync file transfer
    #
    # The 'archive', 'update', 'dry_run', 'link_dest', 'delete', and
    # 'delete_excluded' arguments correspond to their respective rsync
    # flags. 'exclude' and 'exclude_from' arguments accept either a
    # list of paths and patterns or a single string.
    @staticmethod
    def rsync(src, dst, archive=True, update=False,
              dry_run=False, link_dest=None,
              exclude=None, exclude_from=None,
              delete=False, delete_excluded=False, wait=True,
              stdout=None, stderr=None, args=None,
              error=False, verbose=False, quiet=False):

        rsync_flags = ["rsync"]

        if archive:
            rsync_flags.append("--archive")

        if update:
            rsync_flags.append("--update")

        if dry_run:
            rsync_flags.append("--dry-run")

        if link_dest:
            rsync_flags += ["--link-dest", link_dest]

        if isinstance(exclude, basestring):
            # Single exclude pattern:
            rsync_flags += ["--exclude", exclude]
        elif exclude:
            # List of exclude patterns:
            for pattern in exclude:
                rsync_flags += ["--exclude", pattern]

        if isinstance(exclude_from, basestring):
            # Single exclude path:
            rsync_flags += ["--exclude-from", exclude_from]
        elif exclude_from:
            # List of exclude paths:
            for path in exclude_from:
                rsync_flags += ["--exclude-from", path]

        if delete:
            rsync_flags.append("--delete")

        if delete_excluded:
            rsync_flags.append("--delete-excluded")

        if args:
            rsync_flags += args

        if not quiet:
            rsync_flags += ["--verbose",
                            "--human-readable",
                            "--progress"]

        # Add source and destination operands after flags:
        rsync_flags += [src, dst]

        return Util.p_exec(rsync_flags, stdout=stdout, stderr=stderr,
                           wait=wait, error=error, verbose=verbose)


    # printf() - Format and print a message
    #
    # If both 'colour' and 'prefix' are provided, then colourise only
    # the prefix. If no 'prefix' is provided, colourise the whole
    # message.
    @staticmethod
    def printf(msg, prefix=None, colour=None):
        string = Colours.RESET

        if colour:
            string += colour

        if prefix:
            string += prefix + Colours.RESET + ": "

        string += msg + Colours.RESET

        print string


    # colourise() - Colourise a string
    #
    # Returns the given string wrapped in colour escape codes.
    @staticmethod
    def colourise(string, colour):
        return colour + string + Colours.RESET


#
# Shell escape colour codes.
#
class Colours:
    RESET   = '\033[0m'
    GREEN   = '\033[92m'
    YELLOW  = '\033[93m'
    BLUE    = '\033[94m'
    RED     = '\033[91m'

    OK      = GREEN
    INFO    = BLUE
    WARNING = YELLOW
    ERROR   = RED

    SNAPSHOT_DELETE = RED
    SNAPSHOT_NEW    = BLUE
