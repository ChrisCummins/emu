#!/usr/bin/env python
#
# Copyright 2014 Chris Cummins.
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
import os
import re
import shutil
import subprocess
import sys
from ConfigParser import ConfigParser
from optparse import OptionParser
from sys import exit


class SnapshotNotFoundError(Exception):
    def __init__(self, hash, stack=''):
        self.hash = hash
        self.stack = stack
    def __str__(self):
        if len(self.stack):
            name = self.stack + ":" + self.hash
        else:
            name = self.hash
        return "Snapshot '{0}' not found!".format(name)

class Node:
    def __init__(self, path):
        with open(path, 'r') as f:
            node = f.read()
            self.data = {}
            for l in node.rstrip().split('\n'):
                p = re.split(r"\W+", l, 1)
                self.data[p[0]] = p[1]


class Snapshot:
    def __init__(self, shash, stack_name, stack_dir):
        self.id = shash
        self.stack = stack_name
        self.date = self.id[0:8]
        self.checksum = self.id[8:]
        self.node = stack_dir + "/.emu/nodes/" + shash
        self.tree = stack_dir + "/.emu/trees/" + shash

        if not (os.path.exists(self.node) and os.path.isdir(self.tree)):
            raise SnapshotNotFoundError(shash, stack=stack_name)

    _valid = None
    def verify(self):
        if self._valid == None:
            checksum = Libemu.hash_dir(self.tree)
            self._valid = checksum == self.checksum
        return self._valid

    def __repr__(self):
        return self.stack + ":" + self.id

    def log(self, short=False):
        def full_log(id, node):
            s =  "snapshot " + id + "\n"
            s += "Date:    " + node.data['Date'] + "\n"
            s += "Size:    " + node.data['Size'] + "\n"
            return s
        def short_log(id, node):
            s = id + "  " + node.data['Date']
            return s

        node = Node(self.node)
        if short:
            return short_log(self.id, node)
        else:
            return full_log(self.id, node)


class StackNotFoundError(Exception):
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return "Stack '{0}' not found!".format(self.name)


class Stack:
    re = r"^([^:]+)?(:(([a-f0-9]+)|(HEAD(~([0-9]+)?)?)))?$"

    def _stack(self):
        try:
            return re.sub(self.re, r"\1", self.sid)
        except:
            return ""

    def _snapshot(self):
        try:
            s = re.sub(self.re, r"\3", self.sid)

            # HEAD~ syntax
            if re.match(r"^HEAD.*", s):
                index = 0
                if re.match(r"HEAD~.*", s):
                    index += 1
                    if re.match(r".*\d+", s):
                        index += int(re.sub(r"HEAD~", r"", s)) - 1
                ids = os.listdir(self.path + "/.emu/nodes")
                try:
                    return ids[index]
                except IndexError:
                    SnapshotNotFoundError(self.stack, s)

            return s
        except:
            return ""

    def _path(self):
        try:
            pointer = self.source + "/.emu/stacks/" + self.stack
            with open(pointer, 'r') as f:
                path = f.read().strip()
                if not os.path.exists(path):
                    raise
                return path
        except:
            raise StackNotFoundError(self.sid)

    def _snapshots(self):
        if len(self.snapshot):
            ids = [self.snapshot]
        else:
            ids = os.listdir(self.path + "/.emu/nodes")
        snapshots = []
        for id in ids:
            snapshots.append(Snapshot(id, self.stack, self.path))
        return snapshots

    def get_config(self):
        try:
            return self._config
        except AttributeError:
            self._config = ConfigParser()
            self._config.read(self.path + "/.emu/config")
            return self.get_config()

    def get_max_snapshots(self):
        try:
            return self._max_snapshots
        except AttributeError:
            self._max_snapshots = self.get_config().get('Snapshots', 'Max Number')
            return self.get_max_snapshots()

    def get_disk_usage(self):
        try:
            return self._du
        except AttributeError:
            self._du = Libemu.du(self.path)
            return self.get_disk_usage()

    def __init__(self, snapshot_id, source_dir):
        self.sid = snapshot_id
        self.source = source_dir
        self.stack = self._stack()
        self.path = self._path()
        self.snapshot = self._snapshot()
        self.snapshots = self._snapshots()

    def __str__(self):
        return self.stack + " " + self.path


class SourceCreateError(Exception):
    def __init__(self, source_dir):
        self.source_dir = source_dir
    def __str__(self):
        return "Failed to create source at '{0}'!".format(self.source_dir)


class Source:
    def __init__(self, source_dir):
        self.path = source_dir
        Libemu.exists(self.path, err=True)
        Libemu.exists(self.path + "/.emu", err=True)
        Libemu.exists(self.path + "/.emu/stacks", err=True)

        self.stacks = []
        for stack in os.listdir(self.path + "/.emu/stacks"):
            self.stacks.append(Stack(stack, self.path))


    @staticmethod
    def create(path, template_dir, verbose=False, force=False):
        def err_cb(*data):
            Libemu.rm(source_root, verbose=verbose)
            raise SourceCreateError(source_root)

        # Create directory structure
        source_root = path + "/.emu"
        directories = ["/", "/hooks", "/stacks"]
        for d in directories:
            Libemu.mkdir(source_root + d, mode=0700, verbose=verbose)

        # Copy template files
        Libemu.rsync(template_dir + "/", source_root + "/", err=err_cb,
                     archive=True, verbose=verbose, update=force)

        return Source(path)


class Libemu:
    prefix = "/usr/local"
    global_template_dir = prefix + "/share/emu/templates"
    version = {
        "major": 0,
        "minor": 0,
        "micro": 8
    }
    version_string = (str(version["major"]) + "." +
                      str(version["minor"]) + "." +
                      str(version["micro"]))


    @staticmethod
    def show_version_and_quit(*data):
        print "emu version", Libemu.version_string
        exit(0)


    @staticmethod
    def get_option_parser(name="", args="", desc=""):
        string = ""

        if len(name):
            string = name + " [options]"
            if len(args):
                string += " " + args
            if len(desc):
                string += " - " + desc

        if (len(string)):
            parser = OptionParser(string)
        else:
            parser = OptionParser()

        parser.add_option("-S", "--source-dir", action="store", type="string",
                          dest="source_dir", default=os.getcwd(), metavar="DIR",
                          help="Specify the emu working directory")
        parser.add_option("-V", "--version", action="callback",
                          callback=Libemu.show_version_and_quit,
                          help="Show version information")
        parser.add_option("-v", "--verbose", action="store_true",
                          dest="verbose", default=False,
                          help="Increase verbosity")
        return parser


    @staticmethod
    def get_user_read_permissions(path, err=False):
        r = os.access(path, os.R_OK)
        if err and not r:
            if hasattr(err, '__call__'):
                err() # Error callback
            else:
                print "No read permissions for directory '" + path + "'!"
                exit(1)
        return r


    @staticmethod
    def get_user_write_permissions(path, err=False):
        w = os.access(path, os.W_OK)
        if err and not w:
            if hasattr(err, '__call__'):
                err() # Error callback
            else:
                print "No write permissions for directory '" + path + "'!"
                exit(1)
        return w


    @staticmethod
    def exists(path, err=False):
        exists = os.path.exists(path)
        if err and not exists:
            if hasattr(err, '__call__'):
                err() # Error callback
            else:
                print "'" + path + "' not found!"
                exit(1)
        return exists


    @staticmethod
    def mkdir(path, mode=0777, verbose=False):
        try:
            os.makedirs(path, mode)
            created = True
        except OSError:
            # OSError is thrown if the file already exists. Note that
            # just because it exists, it does not necessarily have the
            # correct permissions, so let's set the mode just in case.
            os.chmod(path, mode)
            created = False
        if verbose and created:
            print "Created directory '{0}' with mode 0{1:o}".format(path, mode)
        return created


    @staticmethod
    def rm(path, verbose=False):
        Libemu.get_user_write_permissions(path, err=True)
        if os.path.isdir(path):
            shutil.rmtree(path)
            if verbose:
                print "Recursively deleted '{0}'".format(path)
            return True
        elif os.path.exists(path):
            os.remove(path)
            if verbose:
                print "Deleted file '{0}'".format(path)
            return True
        else:
            return False


    @staticmethod
    def rsync(src, dest, verbose=False, err=False,
              archive=True, update=False, delete=False):
        cmd = "rsync"

        if verbose:
            cmd += " --verbose --human-readable"
        if archive:
            cmd += " --archive"
        if update:
            cmd += " --update"
        if delete:
            cmd += " --delete"

        ret = os.system(cmd + " '" + src + "' '" + dest + "'")

        if err and ret != 0:
            if hasattr(err, '__call__'):
                err() # Error callback
            else:
                print "Rsync transfer failed!"
                exit(1)

        return ret


    @staticmethod
    def get_snapshots(args, source_dir):
        def resolve(arg, source_dir):
            try:
                return Stack(arg, source_dir).snapshots
            except (StackNotFoundError, SnapshotNotFoundError) as e:
                print e
                sys.exit(1)

        if not len(args):
            args = os.listdir(source_dir + "/.emu/stacks")

        paths = []
        for arg in args:
            paths += resolve(arg, source_dir)

        return paths


    @staticmethod
    def die_if_not_source(path):
        if not (os.path.isdir(path + "/.emu") and
                os.path.exists(path + "/.emu/config")):
            print "No emu source found!"
            sys.exit(1)


    @staticmethod
    def hash_dir(path):
        command = ("cd {0} && find . -type f -printf '%T@ %p\n' 2>/dev/null | "
                   "grep -v ' ./.emu/' | md5sum | awk '{{print $1}}'").format(path)

        return subprocess.check_output(command, shell=True).rstrip()
