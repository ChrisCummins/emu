#!/bin/bash

## VARIABLES ###################################################################

export EMU_VERSION="0.0.3"

# exit codes
export EMU_EXIT=0
export EMU_EXIT_ERROR=1
export EMU_EXIT_INSUFFICIENT_PERMISSIONS=2
export EMU_EXIT_BLOCKED=3
export EMU_EXIT_INCORRECT_COMMAND=126
export EMU_EXIT_COMMAND_NOT_FOUND=127

## HELP AND VERSION ############################################################
print_version() {
    emu_echo "version $EMU_VERSION"
}

print_help() {
    if [ -n "$EMU_ECHO_PREFIX" ]; then
        man "$EMU_ECHO_PREFIX"
    fi
}

exit_on_help_version() {
    for arg in $@; do
        case "$arg" in
            "--help")
                print_help
                exit 0
                ;;
            "--version")
                print_version
                exit 0
                ;;
        esac
    done
}

## ECHO ########################################################################

_emu_echo ()
{
    local msg="$1"
    local stream=$2
    local emu_message_color="$(tput sgr0)"
    local reset_color="$(tput sgr0)"

    echo -n $emu_prefix_color >&$stream
    if [ -z $EMU_ECHO_PREFIX ]
    then
        echo -n "emu" >&$stream
    else
        echo -n "$EMU_ECHO_PREFIX" >&$stream
    fi
    echo -n $emu_message_color >&$stream
    echo -ne ": $msg" >&$stream
    echo $reset_color >&$stream
    echo -n $emu_prefix_color >&$stream
}

# print a message
#  @param $1                         msg
#  @var   EMU_ECHO_PREFIX (optional) output prefix
#  @var   EMU_QUIET       (optional) silences output
emu_echo ()
{
    local msg="$1"

    if [ $(which tput 2>/dev/null) ]
    then
        local emu_prefix_color="$(tput setaf 2)"
    fi

    if ! (( $EMU_QUIET ))
    then
        _emu_echo "$msg" 1
    fi

    return 0
}

# print a warning message
#  @param $1                         msg
#  @var   EMU_ECHO_PREFIX (optional) output prefix
#  @var   EMU_QUIET       (optional) silences output
emu_warning ()
{
    local msg="$1"

    if [ $(which tput 2>/dev/null) ]
    then
        local emu_prefix_color="$(tput setaf 3)"
    fi

    if ! (( $EMU_QUIET ))
    then
        _emu_echo "$msg" 2
    fi

    return 0
}

# print an error message
#  @param $1                         msg
#  @var   EMU_ECHO_PREFIX (optional) output prefix
emu_error ()
{
    local msg="$1"

    if [ $(which tput 2>/dev/null) ]
    then
        local emu_prefix_color="$(tput setaf 1)"
    fi

    _emu_echo "$msg" 2
    return 0
}

## ERRORS ######################################################################

# print 'not a command' text and exit
#  @param $1 name of missing command
command_not_found ()
{
    local command=$1

    emu_echo "'$command' is not an emu command. See 'emu help'."
    exit $EMU_EXIT_COMMAND_NOT_FOUND
}

# panic, execute hooks and prepare for crash
emu_panic ()
{
    get_source_dir_if_empty

    if [ -n "$SOURCE_DIR" ] && is_source "$SOURCE_DIR"
    then
        error_exec_hooks "$SOURCE_DIR"
        unlock_dir "$SOURCE_DIR"

        # unlock all sinks
        for sink_file in "$SOURCE_DIR/.emu/sinks"
        do
            if [[ -f "$sink_file" ]]
            then
                local sink="$(cat $sink_file)"

                unlock_dir "$sink"
            fi
        done
    fi
}

## DIRECTORIES #################################################################

# Returns the absolute path of a given directory
#  @param  $1 (optional) path to directory
#  @return    absolute path
get_absolute_path ()
{
    local dir="$1"

    if [ -z "$dir" ]
    then
        dir="$(pwd -P)"
    else
        # get absolute path
        if [ ${dir:0:1} != "/" ]
        then
            # relative path
            dir="$(pwd)/$dir"
        fi
        pushd . &>/dev/null
        cd "$dir"
        dir="$(pwd -P)"
        popd &>/dev/null
    fi

    echo "$dir"
}

# check for write permissions
#  @var   $SCRIPT (optional) echo prefix
#  @param $1                 path to the directory
exit_if_no_dir_permissions ()
{
    local dir="$1"

    if ! [ -d "$dir" ]
    then
        mkdir -p "$dir"
    fi

    touch "$dir/.emu-permissions-test" &>/dev/null
    if (( $? ))
    then
        emu_error "insufficient user permissions for '$dir'"
        exit $EMU_EXIT_INSUFFICIENT_PERMISSIONS
    fi
    cat "$dir/.emu-permissions-test" &>/dev/null
    local return=$?
    rm -f "$dir/.emu-permissions-test" &>/dev/null

    if (( $return ))
    then
        emu_error "insufficient user permissions for '$dir'"
        exit $EMU_EXIT_INSUFFICIENT_PERMISSIONS
    fi
}

# returns whether a directory is a source or not
#  @param $1 (optional) path to directory
is_source ()
{
    local dir="$1"

    if [ -z "$dir" ]
    then
        dir="$(pwd)"
    fi

    if [[ -f "$dir/.emu/excludes" ]] \
        && [[ -d "$dir/.emu/hooks" ]] \
        && [[ -d "$dir/.emu/sinks" ]]
    then
        return 0
    else
        return 15
    fi
}

_test_source_dir ()
{
    dir="$(pwd -P)"

    if ! is_source "$dir"
    then
        if [[ "$dir" != "/" ]]
        then
            cd ..
            get_source_dir
        else
            # reached top of tree (/), source dir not found
            SOURCE_DIR=""
        fi
    else
        SOURCE_DIR="$dir"
    fi
}

# recurse up a directory tree, looking for an emu source
#  @param   $1          (optional) The directory to start the search for the
#                       source in
#  @return $SOURCE_DIR The source directory, or empty if not found
get_source_dir ()
{
    local dir="$1"

    if [ -z "$dir" ]
    then
        dir="$(pwd)"
    fi

    pushd . &>/dev/null
    # navigate to and recurse the directory tree
    cd "$dir"
    if _test_source_dir
    then
        r=0
    else
        r=1
    fi

    # return to starting position
    popd &>/dev/null

    return $r
}

get_source_dir_if_empty ()
{
    if [ -z "$SOURCE_DIR" ]
    then
        get_source_dir
    fi
}

# looks for an emu source, if it doesn't find one, it exits
get_source_dir_or_fail ()
{
    get_source_dir
    if [ -z "$SOURCE_DIR" ]
    then
        emu_panic
        emu_error "not an emu source"
        exit $EMU_EXIT_ERROR
    fi
}

# returns whether a directory is a sink or not
#  @param $1 (optional) path to directory
is_sink ()
{
    local dir="$1"

    if [ -z "$dir" ]
    then
        dir="$(pwd)"
    fi

    if [[ -f "$dir/.emu/HEAD" ]] \
        && [[ -d "$dir/.emu/nodes" ]]
    then
        return 0
    else
        return 15
    fi
}

_test_sink_dir ()
{
    dir="$(pwd -P)"

    if ! is_sink "$dir"
    then
        if [[ "$dir" != "/" ]]
        then
            cd ..
            get_sink_dir
        else
            # reached top of tree (/), sink dir not found
            SINK_DIR=""
        fi
    else
        SINK_DIR="$dir"
    fi
}

# recurse up a directory tree, looking for an emu sink
#  @param   $1        (optional) The directory to start the search for the
#                     sink in
#  @preturn $SINK_DIR The sink directory, or empty if not found
get_sink_dir ()
{
    local dir="$1"

    if [ -z "$dir" ]
    then
        dir="$(pwd)"
    fi

    pushd . &>/dev/null
    # navigate to and recurse the directory tree
    cd "$dir"
    if _test_sink_dir
    then
        r=0
    else
        r=1
    fi

    # return to starting position
    popd &>/dev/null

    return $r
}

# check and block directory. If the directory is already locked, it will block
# and poll periodically until free
#  @param $1                Path to directory to block on
#  @var   BLOCK_SLEEP_TIME  Time to sleep between block attempts (s)
#  @var   BLOCK_COUNTER     Numeric Variable which must be initialised to 0
#  @var   BLOCK_COUNTER_MAX Maximum number of attempts before failing, or -1 to
#                           continue indefinitely
block_until_dir_free ()
{
    local dir="$1"
    local lock_file="$dir/.emu/LOCK"

    if [[ -f "$lock_file" ]]
    then
        BLOCK_COUNTER=$((BLOCK_COUNTER+1))

        if [[ $BLOCK_COUNTER_MAX -ne -1 ]]
        then
            if [[ $BLOCK_COUNTER -gt $BLOCK_COUNTER_MAX ]]
            then
                emu_error "failed to get exclusive access to directory:\n  $dir"
                emu_panic
                exit $EMU_EXIT_BLOCKED
            fi
        fi

        # print the PID of blocking process
        BLOCK_PID=$(cat "$lock_file" | grep PID | sed -r 's/PID: +//')
        echo -en "\r$1 blocking on process: $BLOCK_PID "

        # print status of blocking process
        BLOCK_STATUS=$(ps -p "$BLOCK_PID")
        if (( $? ))
        then
            echo -n "[dead]"
        else
            echo -n "[$(echo $BLOCK_STATUS | cut -d' ' -f8)]"
        fi
        sleep $BLOCK_SLEEP_TIME
        block_until_dir_free "$dir"
    fi
}

# lock the specified directory
#  @param $1            (optional) path to the directory to lock
#  @var EMU_LOCK_FORCE  set to ignore existing locks
#  @var EMU_LOCK_KILL   set to kill existing lock processes
lock_dir ()
{
    local dir="$1"
    local lock_file="$1/.emu/LOCK"

    if [ -z "$dir" ]
    then
        dir="$(pwd -P)"
    fi

    if (( $EMU_LOCK_FORCE ))
    then
        if [ -f "$lock_file" ] && (( $EMU_LOCK_KILL ))
        then
            # force with kill - kill lock process
            local block_pid=$(cat "$lock_file" | grep PID | sed -r 's/PID:\s+//')
            kill -9 $block_pid
        fi
    else
        # polite
        BLOCK_SLEEP_TIME=1
        BLOCK_COUNTER=0
        BLOCK_COUNTER_MAX=10
        block_until_dir_free "$dir"
    fi

    echo -e "DATE: $(date)\nPID:  $$" > "$dir/.emu/LOCK"
}

# force lock the specified directory, removing any existing locks
#  @param $1 (optional) Path to the directory to lock
lock_dir_force ()
{
    local dir="$1"

    if [ -z "$dir" ]
    then
        dir="$(pwd -P)"
    fi

    echo -e "DATE: $(date)\nPID:  $$" > "$dir/.emu/LOCK"
}

# force lock the specified directory, killing any existing locks
#  @param $1 (optional) Path to the directory to lock
lock_dir_kill ()
{
    local dir="$1"

    if [ -z "$dir" ]
    then
        dir="$(pwd -P)"
    fi

    if [ -f "$dir/.emu/LOCK" ]
    then
        # kill lock process
        local block_pid=$(cat "$dir/.emu/LOCK" | grep PID | sed -r 's/PID: +//')
        kill -9 $block_pid
    fi

    echo -e "DATE: $(date)\nPID:  $$" > "$dir/.emu/LOCK"
}

# remove the lock on source directory
#  @param $1 (optional) Path to directory to lock
unlock_dir ()
{
    local dir="$1"

    if [ -z "$dir" ]
    then
        dir="$(pwd -P)"
    fi

    LOCK=$(cat "$dir/.emu/LOCK" 2> /dev/null)
    if [[ "$LOCK" == "" ]]
    then
        return
    fi
    LOCK_PID=$(echo "$LOCK" | grep PID | sed -r 's/PID: +//')

    if [[ $$ -eq $LOCK_PID ]]
    then
        rm -f "$dir/.emu/LOCK"
    else
        emu_error "cannot free lock $LOCK_PID with key $$"
    fi
}

# generate a 32 digit hash of a directory
#  @param $1 Path to directory
hash_directory ()
{
    pushd . > /dev/null
    cd "$1"
    HASH=$(find . -type f -printf '%T@ %p\n' 2>/dev/null|sort -k 1nr \
        |sed 's/^[^ ]* //'|head -n10|md5sum)
    HASH=${HASH:0:32}
    popd > /dev/null
    echo $HASH
}

## HOOKS #################################################################

_exec_hooks_list ()
{
    local ext="$1"

    get_source_dir_if_empty
    local hooks_list="$(find "$SOURCE_DIR/.emu/hooks/exec/" -name '*.'$ext 2>/dev/null)"

    for exec in $hooks_list
    do
        $exec
    done
}

# execute pre-execution hooks
pre_exec_hooks ()
{
    _exec_hooks_list "pre"
}

# execute post-execution hooks
post_exec_hooks ()
{
    _exec_hooks_list "post"
}

# execute error condition hooks
error_exec_hooks ()
{
    _exec_hooks_list "error"
}

## SINKS #######################################################################

# return the number of snapshots in sink
#  @param $1 Path to sink directory
sink_snapshot_count ()
{
    echo "$(ls -l "$1/.emu/trees" | wc -l)"
}

# return the max number of snapshots for sink
#  @param $1 Path to sink directory
sink_max_snapshots ()
{
    echo "$(cat $1/.emu/config/SNAPSHOT-COUNT)"
}

# prints details about a given sink
#  @param $1          name of the sink
#  @var   $SOURCE_DIR (optional) path of source directory
print_sink_details ()
{
    local sink_name="$1"

    if [ -z "$SOURCE_DIR" ]
    then
        get_source_dir
    fi

    local sink_path="$(cat $SOURCE_DIR/.emu/sinks/$sink_name)"
    local size="$(du -sh $sink_path | sed -r 's/([0-9a-zA-Z]+)\s.*/\1/')"
    local head="$(cat $sink_path/.emu/HEAD)"
    local snapshot_count="$(ls $sink_path/.emu/trees | wc -l)"
    local load=$(echo "$snapshot_count / $(cat $sink_path/.emu/config/SNAPSHOT-COUNT) * 100" | bc -l)

    if (( $EMU_LOG_SUMMARY ))
    then
        # summary sink info
        cat <<EOF
* $1 ($sink_path)
EOF
    else
        # verbose sink info
        cat <<EOF | less
* $1
  Path:           $sink_path
  Size:           $size
  Last snapshot:  $(cat $sink_path/.emu/nodes/$head 2>/dev/null | grep Date | sed -r 's/Date +(.*)/\1/')
  Snapshot count: $snapshot_count (${load::2}%)
EOF
    fi
}

# prints details about a given node
#  @param $1          name of the node
#  @var   $SINK_DIR   directory of the node sink
print_node_details ()
{
    local node="$1"
    local node_path="$SINK_DIR/.emu/nodes/$node"
    local node_date="$(cat $node_path | grep Date | sed -r 's/Date +(.*)/\1/')"
    local node_size="$(cat $node_path | grep Size | sed -r 's/Size +(.*)/\1/')"

    if (( $EMU_LOG_SUMMARY ))
    then
        # summary node info
        cat <<EOF
   $node_date * $node
EOF
    else
        # verbose node info
        cat <<EOF

  $node
    Date: $node_date
    Size: $node_size
EOF
    fi
}

## SNAPSHOTS ###################################################################

# calculate and compare the snapshot hash against the node hash
#  @param $1 Path to snapshot
verify_node ()
{
    NODE=$(basename "$1")
    NODE_HASH=${NODE:0:32}
    HASH=$(hash_directory "$1")

    if [ "$NODE_HASH" = "$HASH" ]
    then
        return 0
    else
        emu_error "verification failed!\n  Expected: $NODE_HASH\n  Actual:   $HASH"
        return 1
    fi
}

# lookup info from an emu node
#  @param  $1 Node path
#  @param  $2 Key
#  @return    Value for key, or empty string if not found
lookup_node_key ()
{
    echo "$(cat $1 2>/dev/null | grep $2 | sed -r 's/'$2' +(.*)/\1/')"
}
